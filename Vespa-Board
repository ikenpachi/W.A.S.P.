#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>
#include <esp_now.h>
#include <RoboCore_Vespa.h>

AsyncWebServer server(80);
AsyncWebSocket ws("/ws");

VespaMotors motores;
VespaBattery vbat;

const uint8_t PINO_LED = 15;
const uint8_t PINO_HCSR04_ECHO = 26;
const uint8_t PINO_HCSR04_TRIGGER = 25;

const char *ALIAS_COMANDO = "comando";
const uint32_t TEMPO_ATUALIZACAO_VBAT = 5000;
uint32_t timeout_vbat;

const uint32_t TEMPO_ATUALIZACAO_DISTANCIA = 100;
uint32_t timeout_distancia;
uint32_t distancia;

// Estrutura de dados recebida do M5
typedef struct struct_message {
  char tipo[10];
  int valor;
} struct_message;

void OnDataRecv(const esp_now_recv_info_t *info, const uint8_t *data, int len) {
  if (len == sizeof(struct_message)) {
    struct_message msg;
    memcpy(&msg, data, sizeof(msg));
    Serial.printf("Dados do M5 recebidos: Tipo: %s | Valor: %d\n", msg.tipo, msg.valor);

    // Exemplo: redirecionar para WebSocket como JSON
    StaticJsonDocument<100> json;
    json[msg.tipo] = msg.valor;
    String out;
    serializeJson(json, out);
    ws.textAll(out);
  } else {
    Serial.println("Tamanho de mensagem inválido recebido por ESP-NOW.");
  }
}

void setup() {
  Serial.begin(115200);
  pinMode(PINO_LED, OUTPUT);
  pinMode(PINO_HCSR04_ECHO, INPUT);
  pinMode(PINO_HCSR04_TRIGGER, OUTPUT);
  digitalWrite(PINO_HCSR04_TRIGGER, LOW);

  WiFi.mode(WIFI_AP);
  WiFi.softAP("WASP", "12345678");
  Serial.println(WiFi.softAPIP());

  // Inicialização ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Erro ao iniciar ESP-NOW");
    return;
  }
  esp_now_register_recv_cb(OnDataRecv);

  configurar_servidor_web();
  server.begin();
}

void configurar_servidor_web(void) {
  ws.onEvent(onEvent);
  server.addHandler(&ws);
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", index_html);
  });
}

void handleWebSocketMessage(void *arg, uint8_t *data, size_t length) {
  AwsFrameInfo *info = (AwsFrameInfo*)arg;
  if (info->final && info->index == 0 && info->len == length && info->opcode == WS_TEXT) {
    data[length] = 0;
    StaticJsonDocument<100> json;
    DeserializationError erro = deserializeJson(json, data);
    if (erro) return;

    if (json.containsKey("velocidade") && json.containsKey("angulo")) {
      int v = json["velocidade"];
      int a = json["angulo"];
      if (a >= 90 && a <= 180)
        motores.turn(v * (135 - a) / 45 , v);
      else if (a >= 0 && a < 90)
        motores.turn(v, v * (a - 45) / 45);
      else if (a > 180 && a <= 270)
        motores.turn(-1 * v, -1 * v * (a - 225) / 45);
      else if (a > 270)
        motores.turn(-1 * v * (315 - a) / 45, -1 * v);
      else
        motores.stop();
      return;
    }

    String comando = json[ALIAS_COMANDO];
    if (comando == "manual") {
      Serial.println("Modo manual ativado.");
    } else if (comando == "auto") {
      Serial.println("Modo automático ativado.");
    } else if (comando == "stop") {
      motores.stop();
      Serial.println("Parado.");
    } else if (comando == "scan") {
      StaticJsonDocument<100> resp;
      resp["scan"]["ssid"] = "Red_Exemplo";
      resp["scan"]["rssi"] = -42;
      String msg;
      serializeJson(resp, msg);
      ws.textAll(msg);
    }
  }
}

int16_t ler_distancia(void) {
  digitalWrite(PINO_HCSR04_TRIGGER, HIGH);
  delayMicroseconds(10);
  digitalWrite(PINO_HCSR04_TRIGGER, LOW);
  return pulseIn(PINO_HCSR04_ECHO, HIGH) / 58;
}

void onEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type,
             void *arg, uint8_t *data, size_t length) {
  if (type == WS_EVT_CONNECT) {
    digitalWrite(PINO_LED, HIGH);
    Serial.printf("Cliente WebSocket #%u conectado\n", client->id());
  } else if (type == WS_EVT_DISCONNECT) {
    digitalWrite(PINO_LED, LOW);
    Serial.printf("Cliente WebSocket #%u desconectado\n", client->id());
  } else if (type == WS_EVT_DATA) {
    handleWebSocketMessage(arg, data, length);
  }
}

void loop() {
  if (millis() > timeout_vbat) {
    if (ws.count() > 0) {
      uint32_t tensao = vbat.readVoltage();
      StaticJsonDocument<50> json;
      json["vbat"] = tensao;
      String msg;
      serializeJson(json, msg);
      ws.textAll(msg);
    }
    timeout_vbat = millis() + TEMPO_ATUALIZACAO_VBAT;
  }

  if (millis() > timeout_distancia) {
    if (ws.count() > 0) {
      float fator = 0.2;
      float leitura = ler_distancia();
      distancia = leitura * fator + (1.0 - fator) * (float)distancia;

      StaticJsonDocument<50> json;
      json["distancia"] = distancia;
      String msg;
      serializeJson(json, msg);
      ws.textAll(msg);
    }
    timeout_distancia = millis() + TEMPO_ATUALIZACAO_DISTANCIA;
  }
}
